name: 'Flow Pull Action'
description: 'Pull the latest version of flow code from Ganymede. This action supports pulling all flows or just a single flow.'
inputs:
  environment:
    description: 'The Ganymede environment to pull from. This value is shown in the URL. For example, if your Ganymede homepage has the URL https://mycompany.ganymede.bio/mycompany-dev/home, you would use mycompany-dev '
    required: true
  ganymede_subdomain:
    description: 'The Ganymede subdomain where the environment is located. If your Ganymede URL is mycompany.ganymede.bio, this would be mycompany'
    required: true
  ganymede_api_token:
    description: 'API token for authenticating with Ganymede'
    required: true
  flow_name:
    description: 'If this field is set, only the specified flow will be pulled. If not set, all flows will be pulled. This is the flow name that is displayed in the URL.'
    required: false
  zip_directory:
    description: 'If this field is set, the flow will be unzipped to the specified directory. If not set, the flow will be unzipped to a directory named as the environment name.'
    required: false
  include_lib_files:
    description: 'If this field is set to true, code in lib/, accessible to all Flows, will be included in the download. Defaults to true.'
    required: false
    default: 'true'
outputs:
  zip_dir:  
    description: "The full path to the zip directory where the flow was unzipped."
    value: ${{ steps.extract-files.outputs.ZIP_DIR }}
runs:
  using: "composite"
  steps:
    - name: Set query parameter
      shell: bash
      id: query_param
      run: |
        # Build query parameters
        QUERY_PARAM=""
        SEPARATOR=""
        
        # Add flow name parameter if specified
        if [ -n "${{ inputs.flow_name }}" ]; then
          QUERY_PARAM="${QUERY_PARAM}${SEPARATOR}flowName=${{ inputs.flow_name }}"
          SEPARATOR="&"
        fi
        
        # Add includeLibFiles parameter if set to true
        if [ "${{ inputs.include_lib_files }}" = "true" ]; then
          QUERY_PARAM="${QUERY_PARAM}${SEPARATOR}includeLibFiles=true"
          SEPARATOR="&"
        fi
        
        # Add leading ? if we have any parameters
        if [ -n "$QUERY_PARAM" ]; then
          QUERY_PARAM="?$QUERY_PARAM"
        fi
        
        echo "QUERY_PARAM=$QUERY_PARAM" >> $GITHUB_ENV
        
    - name: Checkout repository
      uses: actions/checkout@v5

    - name: Make API call to get signed URL
      id: get_signed_url
      shell: bash
      run: |
        response=$(curl -w "\n%{http_code}" --location "https://${{ inputs.ganymede_subdomain }}.ganymede.bio/v0/environment/${{ inputs.environment}}/commits${{env.QUERY_PARAM}}" \
              --header 'api-key: ${{ inputs.ganymede_api_token }}')
        status_code=$(echo "$response" | tail -n1)
        body=$(echo "$response" | sed '$ d')
        
        if [ "$status_code" -ne 200 ]; then
          echo "Error: Received status code $status_code"
          echo "Response: $body"
          exit 1
        fi
        
        SIGNED_URL=$body
        echo "SIGNED_URL=$SIGNED_URL" >> $GITHUB_ENV

    - name: Download ZIP file
      shell: bash
      run: |
        curl -s -L "${{ env.SIGNED_URL }}" -o files.zip
        echo "Downloaded zip file"

    - name: Extract files
      shell: bash
      id: extract-files
      run: |
        TARGET_DIR="${{ inputs.zip_directory || inputs.environment }}"
        FLOW_NAME="${{ inputs.flow_name }}"

        # Create temp directory for extraction
        TEMP_DIR=$(mktemp -d)

        # Extract ZIP to temp directory
        unzip -o -q files.zip -d "$TEMP_DIR"

        # Create target directory if it doesn't exist
        mkdir -p "$TARGET_DIR"

        if [ -n "$FLOW_NAME" ]; then
          # Single flow mode: Only sync the specified flow (and lib if present)
          for dir in "$TEMP_DIR"/*; do
            if [ -d "$dir" ]; then
              dir_name=$(basename "$dir")
              TARGET_SUBDIR="$TARGET_DIR/$dir_name"
              TEMP_SUBDIR="$TEMP_DIR/$dir_name"

              # If this subdirectory exists in target, clean it up
              if [ -d "$TARGET_SUBDIR" ]; then
                # Save current directory
                ORIGINAL_DIR=$(pwd)
                cd "$TARGET_SUBDIR"

                # Find and remove files that don't exist in temp
                find . -type f | while read -r file; do
                  clean_file="${file#./}"
                  if [ ! -f "$TEMP_SUBDIR/$clean_file" ]; then
                    echo "Removing deleted file: $dir_name/$clean_file"
                    rm "$file"
                  fi
                done

                # Remove empty directories
                find . -type d -empty -delete 2>/dev/null || true

                cd "$ORIGINAL_DIR"
              fi
            fi
          done
        else
          # All flows mode: Sync entire directory
          # First, remove directories and files in target that don't exist in temp
          if [ -d "$TARGET_DIR" ]; then
            ORIGINAL_DIR=$(pwd)
            cd "$TARGET_DIR"

            # Remove entire flow directories that don't exist in the new download
            find . -mindepth 1 -maxdepth 1 -type d | while read -r dir; do
              dir_name=$(basename "$dir")
              if [ ! -d "$TEMP_DIR/$dir_name" ]; then
                echo "Removing deleted flow directory: $dir_name"
                rm -rf "$dir_name"
              fi
            done

            # Find all remaining files in target and remove those not in temp
            find . -type f | while read -r file; do
              clean_file="${file#./}"
              if [ ! -f "$TEMP_DIR/$clean_file" ]; then
                echo "Removing deleted file: $clean_file"
                rm "$file"
              fi
            done

            # Remove empty directories
            find . -type d -empty -delete 2>/dev/null || true

            cd "$ORIGINAL_DIR"
          fi
        fi

        # Copy all extracted files to target (overwrites existing)
        cp -r "$TEMP_DIR"/* "$TARGET_DIR"/

        # Clean up
        rm -rf "$TEMP_DIR"
        rm files.zip

        # Get the full path of the zip directory for output
        ZIP_DIR=$(realpath "$TARGET_DIR")
        echo "ZIP_DIR=${ZIP_DIR}" >> $GITHUB_OUTPUT